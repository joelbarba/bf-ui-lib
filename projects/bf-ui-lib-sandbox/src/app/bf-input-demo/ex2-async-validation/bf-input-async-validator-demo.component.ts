import {AfterViewInit, Component, OnDestroy, OnInit} from '@angular/core';
import {BfGrowlService} from '../../../../../bf-ui-lib/src/lib/bf-growl/bf-growl.service';
import {IbfInputCtrl} from '../../../../../bf-ui-lib/src/lib/bf-input/bf-input.component';
import {Router} from '@angular/router';
import {Subject} from 'rxjs';
import {debounceTime, distinctUntilChanged, switchMap} from 'rxjs/operators';
import {SubSink} from 'subsink';

@Component({
  selector: 'app-bf-input-async-validator-demo',
  templateUrl: './bf-input-async-validator-demo.component.html',
  styleUrls: ['./bf-input-async-validator-demo.component.scss']
})
export class BfInputAsyncValidatorDemoComponent implements OnInit, AfterViewInit, OnDestroy {
  private subs = new SubSink();

  constructor(
    public growl: BfGrowlService,
    public router: Router,
  ) {

    this.setValidation();

    // setTimeout(() => this.val1 = '123',  200);
    // setTimeout(() => this.val1 = 'xxx', 1000);
    // setTimeout(() => this.val1 = 'AAA', 1100);
    // setTimeout(() => this.val1 = 'xxx', 1200);
  }

  public asyncVal$ = new Subject();
  public asyncOp: {value, result?};

  public val1;
  public isLinked = true;
  public inputRef: IbfInputCtrl; // bf-input controller object (ctrlObject)

  public codeEx = `public asyncVal$ = new Subject();
public asyncOp: {value, result?};

this.asyncVal$.pipe(
  debounceTime(this.valEx.debounceTime),
  distinctUntilChanged((prev: any, next) => !prev || prev.value === next.value)
).subscribe(({ value, ctrl }) => {
  
  // Don't trigger the validation again for the same value
  if (!this.asyncOp || this.asyncOp.value !== value) {

    this.asyncOp = { value };
    this.valEx.hasIcon = true; this.valEx.bfIcon = 'loading';
    setTimeout(() => {  // <-- Mocking webapi request
      if (this.asyncOp.value !== value) { 
        return false; // Drop it, if it's changed (there's a newer value)
      }

      this.asyncOp.result = (value === 'AAA'); // Mocking a validation

      if (this.asyncOp.result) {
        ctrl.removeError();
        this.valEx.bfIcon = 'icon-checkmark4';

      } else {
        ctrl.addError({label: 'wrooong'});
        this.valEx.bfIcon = 'icon-thumbs-down';
      }
    }, this.valEx.timeoutMock);
  }
});`;


  // ---- This is the logic to manage autogenerated code example ----
  public brStr = `\n`;
  public bsStr = `\n          `;
  public customCompCode = ``;
  public valCompCode = '';
  public valEx: any = {
    hasErrOnPristine: true, isDisabled: false, errorPos: '', errorPosOpts : [
      { id: 'top-right',    text: 'top-right',  },
      { id: 'bottom-left',  text: 'bottom-left',   },
      { id: 'bottom-right', text: 'bottom-right',  },
    ],
    bfType: 'text', inputTypes: [
      { id: 'text',     text: 'text',     },
      { id: 'number',   text: 'number',   },
      { id: 'password', text: 'password', },
      { id: 'email',    text: 'email',    },
    ],
    hasInvalidIcon: false,  bfInvalidIcon: 'icon-thumbs-down',
    hasValidIcon: false,    bfValidIcon: 'icon-checkmark4',
    hasErrorText: false,    bfErrorText: 'view.common.custom_error',
    hasIcon: false,         bfIcon: 'icon-search', // bfIcon: 'loading',

    isRequired: true,
    bfValMatchVal: 'AAA',

    debounceTime: 500, timeoutMock: 3000
  };

  ngOnInit() {
    this.upComp();
  }
  ngAfterViewInit() {} // console.log('EXT - ngAfterViewInit');
  ngOnDestroy() { this.subs.unsubscribe(); }

  public upComp = () => {
    this.valCompCode = `<bf-input #bfInputRef="ngModel"`;
    this.valCompCode += this.bsStr + `[(ngModel)]="myVariable"`;
    if (this.valEx.hasErrOnPristine)  { this.valCompCode += this.bsStr + `bfErrorOnPristine="true"`; }
    if (this.valEx.isDisabled)        { this.customCompCode += this.bsStr + `[bfDisabled]="true"`; }
    if (this.valEx.errorPos)          { this.valCompCode += this.bsStr + `bfErrorPos="${this.valEx.errorPos}"`; }
    if (this.valEx.inputType !== 'text') { this.customCompCode += this.bsStr + `bfType="${this.valEx.inputType}"`; }

    if (this.valEx.hasInvalidIcon)  { this.valCompCode += this.bsStr + `bfInvalidIcon="${this.valEx.bfInvalidIcon}"`; }
    if (this.valEx.hasValidIcon)    { this.valCompCode += this.bsStr + `bfValidIcon="${this.valEx.bfValidIcon}"`; }
    if (this.valEx.hasErrorText)    { this.valCompCode += this.bsStr + `bfErrorText="${this.valEx.bfErrorText}"`; }
    if (this.valEx.hasIcon)         { this.valCompCode += this.bsStr + `bfIcon="${this.valEx.bfIcon}"`; }

    if (this.valEx.isRequired)  { this.valCompCode += this.bsStr + `bfRequired="true"`; }
    this.valCompCode += this.bsStr + `[bfValidator]="bfValidatorFn"`;
    this.valCompCode += this.bsStr + `(bfOnLoaded)="ctrl = $event"`;
    this.valCompCode += (`>` + this.brStr + `</bf-input>`);

    if (this.valEx.hasManualErr) {
      this.valCompCode += `\n \n public ctrl: IbfInputCtrl; // bfInput controller object\n`;
      this.valCompCode += ` ctrl.addError({ label: 'manual error here' });\n`;
      this.valCompCode += ` ctrl.removeError();\n`;
    }
  };

  public reLink = () => {
    this.isLinked = false;
    setTimeout(() => this.isLinked = true, 500);
  };


  public bfAsyncValidatorFn = (value, ops) => {
    if (!ops.errors) { this.asyncVal$.next(ops); } // If other errors, don't validate
    return ops.errors;
  };

  public setValidation = () => {
    this.subs.unsubscribe();
    this.subs.add(this.asyncVal$.pipe(
      debounceTime(this.valEx.debounceTime),
      distinctUntilChanged((prev: any, next) => !prev || prev.value === next.value)
    ).subscribe(({ value, ctrl }) => {
      if (!this.asyncOp || this.asyncOp.value !== value) {  // Don't trigger the validation again for the same value

        this.asyncOp = { value };
        this.growl.success('Running Async Validation for: ' + value);
        this.valEx.hasIcon = true; this.valEx.bfIcon = 'loading';
        setTimeout(() => {
          if (this.asyncOp.value !== value) { return false; } // In case the value has changed, drop the result

          this.asyncOp.result = (value === 'AAA'); // Mock a validation

          if (this.asyncOp.result) {
            ctrl.removeError();
            this.valEx.bfIcon = 'icon-checkmark4';

          } else {
            ctrl.addError({label: 'wrooong'});
            this.valEx.bfIcon = 'icon-thumbs-down';
          }
        }, this.valEx.timeoutMock);
      }
    }));
  }

}



